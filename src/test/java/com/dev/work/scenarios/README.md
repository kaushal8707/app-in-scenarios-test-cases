
As we should know by now, a parameterized test executes the same test multiple times with different arguments.

## Limitations of @ValueSource

# One of the limitations of value sources is that they only support these types:

short (with the shorts attribute)
byte (bytes attribute)
int (ints attribute)
long (longs attribute)
float (floats attribute)
double (doubles attribute)
char (chars attribute)
java.lang.String (strings attribute)
java.lang.Class (classes attribute)
# Also, we can only pass one argument to the test method each time.

# Before going any further, note that we didn’t pass null as an argument. That’s another limitation — we can’t pass null through a @ValueSource, even for String and Class.


# Csv Literals
we need argument sources capable of passing multiple arguments.

The @CsvSource is one of those sources:

The @CsvSource accepts an array of comma-separated values, and each array entry corresponds to a line in a CSV file.

This source takes one array entry each time, splits it by a comma, and passes each array to the annotated test method as separate parameters. ----By default, the comma is the column separator, but we can customize it using the delimiter attribute:
Now it’s a colon-separated value, so still a CSV


# CSV Files
Instead of passing the CSV values inside the code, we can refer to an actual CSV file

The resources attribute represents the CSV file resources on the classpath to read. And, we can pass multiple files to it.

The numLinesToSkip attribute represents the number of lines to skip when reading the CSV files. By default, @CsvFileSource does not skip any lines, but this feature is usually useful for skipping the header lines as we did here.


# Method Source
The argument sources we’ve covered so far are somewhat simple and share one limitation. It’s hard or impossible to pass complex objects using them.

One approach to providing more complex arguments is to use a method as an argument source.
# .
If we’re going to provide just one argument per test invocation, then it’s not necessary to use the Arguments abstraction:
When we don’t provide a name for the @MethodSource, JUnit will search for a source method with the same name as the test method.

# .
Sometimes, it’s useful to share arguments between different test classes. In these cases, we can refer to a source method 
outside of the current class by its fully qualified name:

. Using the FQN#methodName format, we can refer to an external static method.


# Argument Accessor
By default, each argument provided to a parameterized test corresponds to a single method parameter. Consequently, 
when passing a handful of arguments via an argument source, the test method signature gets very large and messy.

One approach to address this issue is to encapsulate all passed arguments into an instance of ArgumentsAccessor and 
retrieve arguments by index and type.


# Argument Aggregator
Using the ArgumentsAccessor abstraction directly may make the test code less readable or reusable. In order to address these issues, we can write a custom and reusable aggregator.

To do that, we implement the ArgumentsAggregator interface:


# Dynamic Tests
The standard tests annotated with @Test annotation are static tests which are fully specified at the compile time. A DynamicTest is a test generated during runtime. These tests are generated by a factory method annotated with the @TestFactory annotation.

A @TestFactory method must return a Stream, Collection, Iterable, or Iterator of DynamicTest instances. Returning anything else will result in a JUnitException since the invalid return types cannot be detected at compile time. Apart from this, a @TestFactory method cannot be static or private.

The DynamicTests are executed differently than the standard @Tests and do not support lifecycle callbacks. Meaning, the @BeforeEach and the @AfterEach methods will not be called for the DynamicTests.


